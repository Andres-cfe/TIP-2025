!function(t){"use strict";class e{
/**
     * @constructor
     * @param {Object} config - Configuración del cuestionario.
     * @param {string} config.excelFileUrl - URL del archivo Excel que contiene las preguntas.
     * @param {Object} [config.mandatoryFields] - Campos obligatorios en el archivo Excel para el cuestionario.
     * @param {string} [config.mandatoryFields.question="pregunta"] - Nombre de la columna para el texto de la pregunta.
     * @param {string} [config.mandatoryFields.correctOption="opcion_c"] - Nombre de la columna que identifica la respuesta correcta.
     * @param {string} [config.mandatoryFields.correctFeedback="retroalimentacion_correcta"] - Nombre de la columna para la retroalimentación en respuestas correctas.
     * @param {string} [config.mandatoryFields.incorrectFeedback="retroalimentacion_incorrecta"] - Nombre de la columna para la retroalimentación en respuestas incorrectas.
     * @param {string} [config.optionPrefix="opcion"] - Prefijo utilizado para identificar las columnas de las opciones de respuesta.
     * @param {boolean} [config.randomizeQuestions=false] - Indica si las preguntas deben presentarse en orden aleatorio.
     * @param {boolean} [config.randomizeOptions=false] - Indica si las opciones dentro de una pregunta deben ordenarse aleatoriamente.
     * @param {number} [config.passingScore=80] - Puntaje mínimo necesario para aprobar el cuestionario, expresado en porcentaje.
     * @param {number} [config.defaultWeight=1] - Ponderación por defecto asignada a cada pregunta, si no se especifica en el archivo Excel.
     * @param {number} [config.maxQuestions=Infinity] - Número máximo de preguntas a incluir en el cuestionario. Si no se especifica, se incluyen todas las preguntas.
     * @param {number} [config.maxAttempts=Infinity] - Número máximo de intentos permitidos para completar el cuestionario. Por defecto, es infinito.
     * @license Licencia Comercial Propietaria
     * @version 1.0.0
     * @author Salvador Martínez
     * @copyright Este software está protegido por derechos de autor y es propiedad de E360 Digital Solutions S.A. de C.V.
     * El uso está restringido a los términos y condiciones establecidos en el contrato de licencia.
     * Para obtener una licencia y acceder a las características completas y soporte, contáctenos en licencias@espacio360.com.mx
     */
constructor(t){this.config={excelFileUrl:t.excelFileUrl,mandatoryFields:t.mandatoryFields||{question:"pregunta",correctOption:"opcion_c",correctFeedback:"retroalimentacion_correcta",incorrectFeedback:"retroalimentacion_incorrecta"},optionPrefix:t.optionPrefix||"opcion",randomizeQuestions:t.randomizeQuestions||!1,randomizeOptions:t.randomizeOptions||!1,passingScore:t.passingScore||80,defaultWeight:t.defaultWeight||1,maxAttempts:t.maxAttempts||1/0,maxQuestions:t.maxQuestions||1/0},this.questions=[],this.currentQuestionIndex=0,this.correctAnswersCount=0,this.incorrectAnswersCount=0,this.totalScore=0,this.attempts=0}async loadQuestionsFromExcel(){const t=await e.readExcelFile(this.config.excelFileUrl),s=t[Object.keys(t)[0]];if(!Array.isArray(s))return;let i=e.processQuestions(s,this.config);this.config.randomizeQuestions&&(i=e.shuffle(i));const r=i.length;if(this.config.maxQuestions!==1/0&&this.config.maxQuestions>r)throw new Error(`El número máximo de preguntas especificado (${this.config.maxQuestions}) excede el total disponible (${r}).`);this.questions=this.config.maxQuestions===1/0?i:i.slice(0,this.config.maxQuestions)}static async readExcelFile(t){try{const e=await fetch(t),s=await e.arrayBuffer(),i=new Uint8Array(s),r=XLSX.read(i,{type:"array"}),n={};return r.SheetNames.forEach((t=>{const e=r.Sheets[t];n[t]=XLSX.utils.sheet_to_json(e)})),n}catch(t){throw t}}static processQuestions(t,s){return t.map((t=>{const i=s.mandatoryFields;if(!t[i.question]||!t[i.correctOption])return null;let r=Object.keys(t).filter((t=>t.startsWith(s.optionPrefix))).map((e=>({id:e,text:t[e]?.trim(),isCorrect:e===i.correctOption})));const n=s.specialOptions||[];let o=[],c=[];r.forEach((t=>{n.some((e=>t.text.toLowerCase().includes(e.toLowerCase())))?o.push(t):c.push(t)})),s.randomizeOptions&&(c=e.shuffle(c)),r=[...c,...o];const a=Object.keys(t).filter((t=>!Object.values(i).includes(t)&&!t.startsWith(s.optionPrefix))).reduce(((e,s)=>{const i=null!==t[s]&&void 0!==t[s]?String(t[s]).trim():"";return e[s]=i,e}),{}),u=parseFloat(t.ponderacion)||s.defaultWeight;return{question:t[i.question].trim(),options:r,correctFeedback:t[i.correctFeedback]?.trim()||"",incorrectFeedback:t[i.incorrectFeedback]?.trim()||"",additionalInfo:a,weight:u}})).filter(Boolean)}static shuffle(t){for(let e=t.length-1;e>0;e--){const s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t}getCurrentQuestion(){return this.questions[this.currentQuestionIndex]}getNextQuestion(){return this.currentQuestionIndex<this.questions.length-1?(this.currentQuestionIndex++,this.questions[this.currentQuestionIndex]):null}answerQuestionById(t,e){if(t<0||t>=this.questions.length)return;const s=this.questions[t];s.answered||(s.answered=!0,s.isAnswerCorrect=e,e?(this.correctAnswersCount++,this.totalScore+=s.weight):this.incorrectAnswersCount++)}answerCurrentQuestion(t){this.answerQuestionById(this.currentQuestionIndex,t)}answerCurrentQuestionById(t,e){this.answerQuestionById(t,e)}hasMoreQuestions(){return this.questions.filter((t=>t.answered)).length<this.questions.length}getSummary(){const t=this.questions.length,e=this.questions.reduce(((t,e)=>t+e.weight),0),s=Math.round(100*this.totalScore/e),i=s>=this.config.passingScore;return{correct:this.correctAnswersCount,incorrect:this.incorrectAnswersCount,total:t,score:s,maxScore:e,passed:i,attempts:this.attempts,maxAttempts:this.config.maxAttempts}}generateSummaryFromSet(t){const e=Array.from(t),s=e.length,i=e.reduce(((t,e)=>t+(e.weight||1)),0),r=e.filter((t=>t.isAnswerCorrect)).length,n=s-r,o=e.reduce(((t,e)=>e.isAnswerCorrect?t+(e.weight||1):t),0),c=i>0?Math.round(100*o/i):0;return{correct:r,incorrect:n,total:s,score:c,maxScore:i,passed:c>=this.config.passingScore,attempts:this.attempts,maxAttempts:this.config.maxAttempts}}getRenderData(){const t=this.getCurrentQuestion();return t?{text:t.question,options:t.options.map((t=>({id:t.id,text:t.text,isCorrect:t.isCorrect}))),correctFeedback:t.correctFeedback,incorrectFeedback:t.incorrectFeedback,additionalInfo:t.additionalInfo}:null}getQuestionById(t){return t<0||t>=this.questions.length?null:this.questions[t]}getRenderDataById(t){const e=this.getQuestionById(t);return e?{text:e.question,options:e.options.map((t=>({id:t.id,text:t.text,isCorrect:t.isCorrect}))),correctFeedback:e.correctFeedback,incorrectFeedback:e.incorrectFeedback,additionalInfo:e.additionalInfo}:null}getAllRenderData(){return this.questions.map((t=>({text:t.question,options:t.options.map((t=>({id:t.id,text:t.text,isCorrect:t.isCorrect}))),correctFeedback:t.correctFeedback,incorrectFeedback:t.incorrectFeedback,additionalInfo:t.additionalInfo})))}incrementAttempts(){this.attempts++}getAttempts(){return this.attempts}setAttempts(t){isNaN(t)||t<0||(this.attempts=t)}hasReachedMaxAttempts(){return this.attempts>=this.config.maxAttempts}}t.QuizManager=e}(window);